{"version":3,"file":"kg-converters.js","sources":["../lib/lexical-to-mobiledoc.js","../lib/mobiledoc-to-lexical.js"],"sourcesContent":["const MOBILEDOC_VERSION = '0.3.1';\nconst GHOST_VERSION = '4.0';\n\nconst BLANK_DOC = {\n    version: MOBILEDOC_VERSION,\n    ghostVersion: GHOST_VERSION,\n    markups: [],\n    atoms: [],\n    cards: [],\n    sections: [\n        [1, 'p', [\n            [0, [], 0, '']\n        ]]\n    ]\n};\n\nconst MD_TEXT_SECTION = 1;\nconst MD_LIST_SECTION = 3;\nconst MD_CARD_SECTION = 10;\n\nconst MD_TEXT_MARKER = 0;\nconst MD_ATOM_MARKER = 1;\n\nconst L_IS_BOLD = 1;\nconst L_IS_ITALIC = 1 << 1;\nconst L_IS_STRIKETHROUGH = 1 << 2;\nconst L_IS_UNDERLINE = 1 << 3;\nconst L_IS_CODE = 1 << 4;\nconst L_IS_SUBSCRIPT = 1 << 5;\nconst L_IS_SUPERSCRIPT = 1 << 6;\n\nconst L_FORMAT_MAP = new Map([\n    [L_IS_BOLD, 'strong'],\n    [L_IS_ITALIC, 'em'],\n    [L_IS_STRIKETHROUGH, 's'],\n    [L_IS_UNDERLINE, 'u'],\n    [L_IS_CODE, 'code'],\n    [L_IS_SUBSCRIPT, 'sub'],\n    [L_IS_SUPERSCRIPT, 'sup']\n]);\n\nconst HEADING_TYPES = ['heading', 'extended-heading'];\nconst TEXT_TYPES = ['text', 'extended-text'];\n\n// TODO: Feels a little too explicit as it will need updating every time we add a new card.\n//\n// One alternative is to use a list of all built-in Lexical types and assume that anything\n// not listed is a card but that feels more dangerous.\n//\n// Another alternative is to grab the list of cards from kg-default-nodes but that's creating\n// more inter-dependencies that makes development setup tricky.\nconst KNOWN_CARDS = [\n    'audio',\n    'bookmark',\n    'button',\n    'callout',\n    'codeblock',\n    'email-cta',\n    'email',\n    'embed',\n    'file',\n    'gallery',\n    'header',\n    'horizontalrule',\n    'html',\n    'image',\n    'markdown',\n    'paywall',\n    'product',\n    'signup',\n    'toggle',\n    'video'\n];\n\nconst CARD_NAME_MAP = {\n    codeblock: 'code',\n    horizontalrule: 'hr'\n};\n\nconst CARD_PROPERTY_MAP = {\n    embed: {\n        embedType: 'type'\n    }\n};\n\nexport function lexicalToMobiledoc(serializedLexical) {\n    if (serializedLexical === null || serializedLexical === undefined || serializedLexical === '') {\n        return JSON.stringify(BLANK_DOC);\n    }\n\n    const lexical = JSON.parse(serializedLexical);\n\n    if (!lexical.root) {\n        return JSON.stringify(BLANK_DOC);\n    }\n\n    const mobiledoc = buildEmptyDoc();\n\n    lexical.root.children.forEach(child => addRootChild(child, mobiledoc));\n\n    return JSON.stringify(mobiledoc);\n}\n\n/* internal functions ------------------------------------------------------- */\n\nfunction buildEmptyDoc() {\n    return {\n        version: MOBILEDOC_VERSION,\n        ghostVersion: GHOST_VERSION,\n        atoms: [],\n        cards: [],\n        markups: [],\n        sections: []\n    };\n}\n\nfunction getOrSetMarkupIndex(markup, mobiledoc) {\n    let index = mobiledoc.markups.findIndex(m => m[0] === markup);\n\n    if (index === -1) {\n        mobiledoc.markups.push([markup]);\n        index = mobiledoc.markups.length - 1;\n    }\n\n    return index;\n}\n\nfunction getOrSetAtomIndex(atom, mobiledoc) {\n    let index = mobiledoc.atoms.findIndex(m => m[0] === atom);\n\n    if (index === -1) {\n        mobiledoc.atoms.push(atom);\n        index = mobiledoc.atoms.length - 1;\n    }\n\n    return index;\n}\n\nfunction addRootChild(child, mobiledoc) {\n    if (child.type === 'paragraph') {\n        addTextSection(child, mobiledoc);\n    }\n\n    if (HEADING_TYPES.includes(child.type)) {\n        addTextSection(child, mobiledoc, child.tag);\n    }\n\n    if (child.type === 'quote') {\n        addTextSection(child, mobiledoc, 'blockquote');\n    }\n\n    if (child.type === 'aside') {\n        addTextSection(child, mobiledoc, 'aside');\n    }\n\n    if (child.type === 'list') {\n        addListSection(child, mobiledoc, child.tag);\n    }\n\n    if (KNOWN_CARDS.includes(child.type)) {\n        addCardSection(child, mobiledoc);\n    }\n}\n\nfunction addTextSection(childWithFormats, mobiledoc, tagName = 'p') {\n    const markers = buildMarkers(childWithFormats, mobiledoc);\n    const section = [MD_TEXT_SECTION, tagName, markers];\n\n    mobiledoc.sections.push(section);\n}\n\nfunction addListSection(listChild, mobiledoc, tagName = 'ul') {\n    const listItems = buildListItems(listChild, mobiledoc);\n    const section = [MD_LIST_SECTION, tagName, listItems];\n\n    mobiledoc.sections.push(section);\n}\n\nfunction buildListItems(listRoot, mobiledoc) {\n    const listItems = [];\n\n    flattenListChildren(listRoot);\n\n    listRoot.children.forEach((listItemChild) => {\n        if (listItemChild.type === 'listitem') {\n            const markers = buildMarkers(listItemChild, mobiledoc);\n            listItems.push(markers);\n        }\n    });\n\n    return listItems;\n}\n\nfunction flattenListChildren(listRoot) {\n    const flatListItems = [];\n\n    function traverse(item) {\n        item.children?.forEach((child) => {\n            child.children?.forEach((grandchild) => {\n                if (grandchild.type === 'list') {\n                    traverse(grandchild);\n                    child.children.splice(child.children.indexOf(grandchild), 1);\n                }\n            });\n\n            if (child.type === 'listitem' && child.children.length) {\n                flatListItems.push(child);\n            }\n        });\n    }\n\n    traverse(listRoot);\n    listRoot.children = flatListItems;\n}\n\nfunction buildMarkers(childWithFormats, mobiledoc) {\n    const markers = [];\n\n    if (!childWithFormats.children.length) {\n        markers.push([MD_TEXT_MARKER, [], 0, '']);\n    } else {\n        // mobiledoc tracks opened/closed formats across markers whereas lexical\n        // lists all formats for each marker so we need to manually track open formats\n        let openMarkups = [];\n\n        // markup: a specific format, or tag name+attributes\n        // marker: a piece of text with 0 or more markups\n\n        childWithFormats.children.forEach((child, childIndex) => {\n            if (TEXT_TYPES.includes(child.type)) {\n                if (child.format !== 0) {\n                    // text child has formats, track which are new and which have closed\n                    const openedFormats = [];\n                    const childFormats = readFormat(child.format);\n                    let closedFormatCount = 0;\n\n                    childFormats.forEach((format) => {\n                        if (!openMarkups.includes(format)) {\n                            openMarkups.push(format);\n                            openedFormats.push(format);\n                        }\n                    });\n\n                    // mobiledoc will immediately close any formats if the next section doesn't use them or it's not a text section\n                    if (!childWithFormats.children[childIndex + 1] || !TEXT_TYPES.includes(childWithFormats.children[childIndex + 1].type)) {\n                        // no more children, close all formats\n                        closedFormatCount = openMarkups.length;\n                        openMarkups = [];\n                    } else {\n                        const nextChild = childWithFormats.children[childIndex + 1];\n                        const nextFormats = readFormat(nextChild.format);\n                        const firstMissingFormatIndex = openMarkups.findIndex(format => !nextFormats.includes(format));\n\n                        if (firstMissingFormatIndex !== -1) {\n                            const formatsToClose = openMarkups.slice(firstMissingFormatIndex);\n                            closedFormatCount = formatsToClose.length;\n                            openMarkups = openMarkups.slice(0, firstMissingFormatIndex);\n                        }\n                    }\n\n                    const markupIndexes = openedFormats.map(format => getOrSetMarkupIndex(format, mobiledoc));\n                    markers.push([MD_TEXT_MARKER, markupIndexes, closedFormatCount, child.text]);\n                } else {\n                    // text child has no formats so we close all formats in mobiledoc\n                    let closedFormatCount = openMarkups.length;\n                    openMarkups = [];\n\n                    markers.push([MD_TEXT_MARKER, [], closedFormatCount, child.text]);\n                }\n            }\n\n            if (child.type === 'link') {\n                const linkMarkup = ['a', ['href', child.url]];\n                const linkMarkupIndex = mobiledoc.markups.push(linkMarkup) - 1;\n\n                child.children.forEach((linkChild, linkChildIndex) => {\n                    if (linkChild.format !== 0) {\n                        const openedMarkupIndexes = [];\n                        const openedFormats = [];\n\n                        // first child of a link opens the link markup\n                        if (linkChildIndex === 0) {\n                            openMarkups.push(linkMarkup);\n                            openedMarkupIndexes.push(linkMarkupIndex);\n                        }\n\n                        // text child has formats, track which are new and which have closed\n                        const childFormats = readFormat(linkChild.format);\n                        let closedMarkupCount = 0;\n\n                        childFormats.forEach((format) => {\n                            if (!openMarkups.includes(format)) {\n                                openMarkups.push(format);\n                                openedFormats.push(format);\n                            }\n                        });\n\n                        // mobiledoc will immediately close any formats if the next section doesn't use them\n                        if (!child.children[linkChildIndex + 1]) {\n                            // last child of a link closes all markups\n                            closedMarkupCount = openMarkups.length;\n                            openMarkups = [];\n                        } else {\n                            const nextChild = child.children[linkChildIndex + 1];\n                            const nextFormats = readFormat(nextChild.format);\n\n                            const firstMissingFormatIndex = openMarkups.findIndex((markup) => {\n                                const markupIsLink = JSON.stringify(markup) === JSON.stringify(linkMarkup);\n                                return !markupIsLink && !nextFormats.includes(markup);\n                            });\n\n                            if (firstMissingFormatIndex !== -1) {\n                                const formatsToClose = openMarkups.slice(firstMissingFormatIndex);\n                                closedMarkupCount = formatsToClose.length;\n                                openMarkups = openMarkups.slice(0, firstMissingFormatIndex);\n                            }\n                        }\n\n                        openedMarkupIndexes.push(...openedFormats.map(format => getOrSetMarkupIndex(format, mobiledoc)));\n\n                        markers.push([MD_TEXT_MARKER, openedMarkupIndexes, closedMarkupCount, linkChild.text]);\n                    } else {\n                        const openedMarkupIndexes = [];\n\n                        // first child of a link opens the link markup\n                        if (linkChildIndex === 0) {\n                            openMarkups.push(linkMarkup);\n                            openedMarkupIndexes.push(linkMarkupIndex);\n                        }\n\n                        let closedMarkupCount = openMarkups.length - 1; // don't close the link markup, just the others\n\n                        // last child of a link closes all markups\n                        if (!child.children[linkChildIndex + 1]) {\n                            closedMarkupCount += 1; // close the link markup\n                            openMarkups = [];\n                        }\n\n                        markers.push([MD_TEXT_MARKER, openedMarkupIndexes, closedMarkupCount, linkChild.text]);\n                    }\n                });\n            }\n\n            if (child.type === 'linebreak') {\n                const atom = ['soft-return', '', {}];\n                const atomIndex = getOrSetAtomIndex(atom, mobiledoc);\n                markers.push([MD_ATOM_MARKER, [], 0, atomIndex]);\n            }\n        });\n    }\n\n    return markers;\n}\n\n// Lexical stores formats as a bitmask, so we need to read the bitmask to\n// determine which formats are present\nfunction readFormat(format) {\n    const formats = [];\n\n    L_FORMAT_MAP.forEach((value, key) => {\n        if ((format & key) !== 0) {\n            formats.push(value);\n        }\n    });\n\n    return formats;\n}\n\nfunction addCardSection(child, mobiledoc) {\n    const cardType = child.type;\n\n    let cardName = child.type;\n    // rename card if there's a difference between lexical/mobiledoc\n    if (CARD_NAME_MAP[cardName]) {\n        cardName = CARD_NAME_MAP[cardName];\n    }\n    // don't include type in the payload\n    delete child.type;\n\n    // rename any properties to match mobiledoc\n    if (CARD_PROPERTY_MAP[cardType]) {\n        const map = CARD_PROPERTY_MAP[cardType];\n\n        for (const [key, value] of Object.entries(map)) {\n            child[value] = child[key];\n            delete child[key];\n        }\n    }\n\n    const card = [cardName, child];\n    mobiledoc.cards.push(card);\n\n    const cardIndex = mobiledoc.cards.length - 1;\n    const section = [MD_CARD_SECTION, cardIndex];\n\n    mobiledoc.sections.push(section);\n}\n","const BLANK_DOC = {\n    root: {\n        children: [],\n        direction: null,\n        format: '',\n        indent: 0,\n        type: 'root',\n        version: 1\n    }\n};\n\nconst TAG_TO_LEXICAL_NODE = {\n    p: {\n        type: 'paragraph'\n    },\n    h1: {\n        type: 'heading',\n        tag: 'h1'\n    },\n    h2: {\n        type: 'heading',\n        tag: 'h2'\n    },\n    h3: {\n        type: 'heading',\n        tag: 'h3'\n    },\n    h4: {\n        type: 'heading',\n        tag: 'h4'\n    },\n    h5: {\n        type: 'heading',\n        tag: 'h5'\n    },\n    h6: {\n        type: 'heading',\n        tag: 'h6'\n    },\n    blockquote: {\n        type: 'quote'\n    },\n    aside: {\n        type: 'aside'\n    },\n    a: {\n        type: 'link',\n        rel: null,\n        target: null,\n        title: null,\n        url: null\n    }\n};\n\nconst ATOM_TO_LEXICAL_NODE = {\n    'soft-return': {\n        type: 'linebreak',\n        version: 1\n    }\n};\n\nconst MARKUP_TO_FORMAT = {\n    strong: 1,\n    b: 1,\n    em: 1 << 1,\n    i: 1 << 1,\n    s: 1 << 2,\n    u: 1 << 3,\n    code: 1 << 4,\n    sub: 1 << 5,\n    sup: 1 << 6\n};\n\nconst CARD_NAME_MAP = {\n    code: 'codeblock',\n    hr: 'horizontalrule'\n};\n\nconst CARD_PROPERTY_MAP = {\n    embed: {\n        type: 'embedType'\n    }\n};\n\nconst CARD_FIXES_MAP = {\n    callout: (payload) => {\n        if (payload.backgroundColor && !payload.backgroundColor.match(/^[a-zA-Z\\d-]+$/)) {\n            payload.backgroundColor = 'white';\n        }\n\n        return payload;\n    }\n};\n\nexport function mobiledocToLexical(serializedMobiledoc) {\n    if (serializedMobiledoc === null || serializedMobiledoc === undefined || serializedMobiledoc === '') {\n        return JSON.stringify(BLANK_DOC);\n    }\n\n    const mobiledoc = JSON.parse(serializedMobiledoc);\n\n    if (!mobiledoc.sections) {\n        return JSON.stringify(BLANK_DOC);\n    }\n\n    const lexical = buildEmptyDoc();\n\n    mobiledoc.sections.forEach(child => addRootChild(child, mobiledoc, lexical));\n\n    return JSON.stringify(lexical);\n}\n\n/* internal functions ------------------------------------------------------- */\n\nfunction buildEmptyDoc() {\n    return {\n        root: {\n            children: [],\n            direction: null,\n            format: '',\n            indent: 0,\n            type: 'root',\n            version: 1\n        }\n    };\n}\n\nfunction addRootChild(child, mobiledoc, lexical) {\n    const sectionTypeIdentifier = child[0];\n    if (sectionTypeIdentifier === 1) {\n        // Markup (text) section\n        const lexicalChild = convertMarkupSectionToLexical(child, mobiledoc);\n        lexical.root.children.push(lexicalChild);\n\n        // Set direction to ltr if there is any text\n        // Otherwise direction should be null\n        // Not sure if this is necessary:\n        // if we don't plan to support RTL, we could just set 'ltr' in all cases and ignore null\n        if (lexicalChild.children?.length > 0) {\n            lexical.root.direction = 'ltr';\n        }\n    } else if (sectionTypeIdentifier === 2) {\n        // Image section\n        // Not used in Ghost\n    } else if (sectionTypeIdentifier === 3) {\n        // List section\n        const lexicalChild = convertListSectionToLexical(child, mobiledoc);\n        lexical.root.children.push(lexicalChild);\n        lexical.root.direction = 'ltr'; // mobiledoc only supports LTR\n    } else if (sectionTypeIdentifier === 10) {\n        // Card section\n        const lexicalChild = convertCardSectionToLexical(child, mobiledoc);\n        lexical.root.children.push(lexicalChild);\n    }\n}\n\nfunction convertMarkupSectionToLexical(section, mobiledoc) {\n    const tagName = section[1]; // e.g. 'p'\n    const markers = section[2]; // e.g. [[0, [0], 0, \"Hello world\"]]\n\n    // Create an empty Lexical node from the tag name\n    // We will add nodes to the children array later\n    const lexicalNode = createEmptyLexicalNode(tagName);\n\n    populateLexicalNodeWithMarkers(lexicalNode, markers, mobiledoc);\n\n    return lexicalNode;\n}\n\nfunction populateLexicalNodeWithMarkers(lexicalNode, markers, mobiledoc) {\n    const markups = mobiledoc.markups;\n    const atoms = mobiledoc.atoms;\n\n    // Initiate some variables before looping over all the markers\n    let openMarkups = []; // tracks which markup tags are open for the current marker\n    let linkNode = undefined; // tracks current link node or undefined if no a tag is open\n    let href = undefined; // tracks the href for the current link node or undefined if no a tag is open\n    let rel = undefined; //tracks the rel attribute for the current link node or undefined if no a tag is open\n    let openLinkMarkup = false; // tracks whether the current node is a link node\n\n    // loop over markers and convert each one to lexical\n    for (let i = 0; i < markers.length; i++) {\n        // grab the attributes from the current marker\n        const [\n            textTypeIdentifier,\n            openMarkupsIndexes,\n            numberOfClosedMarkups,\n            value\n        ] = markers[i];\n\n        // Markers are either text (markup) or atoms\n        const markerType = textTypeIdentifier === 0 ? 'markup' : 'atom';\n\n        // If the current marker is an atom, convert the atom to Lexical and add to the node\n        if (markerType === 'atom') {\n            const atom = atoms[value];\n            const atomName = atom[0];\n            const childNode = ATOM_TO_LEXICAL_NODE[atomName];\n            embedChildNode(lexicalNode, childNode);\n            continue;\n        }\n\n        // calculate which markups are open for the current marker\n        openMarkupsIndexes.forEach((markupIndex) => {\n            const markup = markups[markupIndex];\n            // Extract the href from the markup if it's a link\n            if (markup[0] === 'a') {\n                openLinkMarkup = true;\n                if (markup[1] && markup[1][0] === 'href') {\n                    href = markup[1][1];\n                }\n\n                if (markup[1] && markup[1][2] === 'rel') {\n                    rel = markup[1][3];\n                }\n            }\n            // Add the markup to the list of open markups\n            openMarkups.push(markup);\n        });\n\n        if (value !== undefined) {\n            // Convert the open markups to a bitmask compatible with Lexical\n            const format = convertMarkupTagsToLexicalFormatBitmask(openMarkups);\n\n            // If there is an open link tag, add the text to the link node\n            // Otherwise add the text to the parent node\n            if (openLinkMarkup) { // link is open\n                // Create an empty link node if it doesn't exist already\n                linkNode = linkNode !== undefined ? linkNode : createEmptyLexicalNode('a', {url: href, rel: rel || null});\n\n                // Create a text node and add it to the link node\n                const textNode = createTextNode(value, format);\n                embedChildNode(linkNode, textNode);\n            } else {\n                const textNode = createTextNode(value, format);\n                embedChildNode(lexicalNode, textNode);\n            }\n        }\n\n        // Close any markups that are closed after the current marker\n        // Remove any closed markups from openMarkups list\n        for (let j = 0; j < numberOfClosedMarkups; j++) {\n            // Remove the most recently opened markup from the list of open markups\n            const markup = openMarkups.pop();\n\n            // If we're closing a link tag, add the linkNode to the node\n            // Reset href and linkNode for the next markup\n            if (markup && markup[0] === 'a') {\n                embedChildNode(lexicalNode, linkNode);\n                openLinkMarkup = false;\n                href = undefined;\n                linkNode = undefined;\n            }\n        }\n    }\n}\n\n// Creates a text node from the given text and format\nfunction createTextNode(text, format) {\n    return {\n        detail: 0,\n        format: format,\n        mode: 'normal',\n        style: '',\n        text: text,\n        type: 'text',\n        version: 1\n    };\n}\n\n// Creates an empty Lexical node from the given tag name and additional attributes\nfunction createEmptyLexicalNode(tagName, attributes = {}) {\n    const nodeParams = TAG_TO_LEXICAL_NODE[tagName];\n    const node = {\n        children: [],\n        direction: 'ltr',\n        format: '',\n        indent: 0,\n        ...nodeParams,\n        ...attributes,\n        version: 1\n    };\n    return node;\n}\n\n// Adds a child node to a parent node\nfunction embedChildNode(parentNode, childNode) {\n    // If there is no child node, do nothing\n    if (!childNode) {\n        return;\n    }\n    // Add textNode to node's children\n    parentNode.children.push(childNode);\n\n    // If there is any text (e.g. not a blank text node), set the direction to ltr\n    if (childNode && 'text' in childNode && childNode.text) {\n        parentNode.direction = 'ltr';\n    }\n}\n\n// Lexical stores formats as a bitmask\n// Mobiledoc stores formats as a list of open markup tags\n// This function converts a list of open tags to a bitmask compatible with lexical\nfunction convertMarkupTagsToLexicalFormatBitmask(tags) {\n    let format = 0;\n    tags.forEach((tag) => {\n        if (tag in MARKUP_TO_FORMAT) {\n            format = format | MARKUP_TO_FORMAT[tag];\n        }\n    });\n    return format;\n}\n\nfunction convertListSectionToLexical(child, mobiledoc) {\n    const tag = child[1];\n    const listType = tag === 'ul' ? 'bullet' : 'number';\n    const listNode = createEmptyLexicalNode(tag, {tag, type: 'list', listType, start: 1, direction: 'ltr'});\n\n    child[2]?.forEach((listItem, i) => {\n        const listItemNode = createEmptyLexicalNode('li', {type: 'listitem', value: i + 1, direction: 'ltr'});\n        populateLexicalNodeWithMarkers(listItemNode, listItem, mobiledoc);\n        listNode.children.push(listItemNode);\n    });\n\n    return listNode;\n}\n\nfunction convertCardSectionToLexical(child, mobiledoc) {\n    let [cardName, payload] = mobiledoc.cards[child[1]];\n\n    // rename card if there's a difference between mobiledoc and lexical\n    cardName = CARD_NAME_MAP[cardName] || cardName;\n\n    // rename any properties to match lexical\n    if (CARD_PROPERTY_MAP[cardName]) {\n        const map = CARD_PROPERTY_MAP[cardName];\n\n        for (const [oldName, newName] of Object.entries(map)) {\n            payload[newName] = payload[oldName];\n            delete payload[oldName];\n        }\n    }\n\n    // run any payload fixes\n    if (CARD_FIXES_MAP[cardName]) {\n        payload = CARD_FIXES_MAP[cardName](payload);\n    }\n\n    delete payload.type;\n    const decoratorNode = {type: cardName, ...payload};\n\n    return decoratorNode;\n}\n"],"names":["BLANK_DOC","CARD_NAME_MAP","CARD_PROPERTY_MAP","buildEmptyDoc","addRootChild"],"mappings":"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"}